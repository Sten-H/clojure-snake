<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1429024419216">{:repl-history {:ide [], :local [&quot;(mapv #(vec (list % 50)) (range 40 50))&quot; &quot;(mapv + [1 1] [3 4])&quot; &quot;(doc disj)&quot; &quot;(disj #{[1 2] [3 2] [4 5]} [3 2])&quot; &quot;(disj #{[1 2] [3 2] [4 5]})&quot; &quot;(def a (atom 0))&quot; &quot;(add-watch a :key (fn [k r os ns] (print k r os ns)))&quot; &quot;(swap! inc @a)&quot; &quot;(add-watch a :key (fn [ka ra os ns] (print ka ra os ns)))&quot; &quot;(swap! a inc)&quot; &quot;(get #{[1 2]} [[0 1] [ 1 2]])&quot; &quot;(get [1 2] [[0 1] [ 1 2]])&quot; &quot;(get #{[1 2]} (first [[1 2] [0 1]]))&quot; &quot;(get #{[1 2]} (first [[0 2] [0 1]]))&quot; &quot;(map conj ())&quot; &quot;(range 1 10)&quot; &quot;(map conj (range 1 10) (range 1 10))&quot; &quot;(map cons (range 1 10) (range 1 10))&quot; &quot;(zipmap (range 1 10) (range 1 10))&quot; &quot;(doseq [[x y] (range 1 10)] (println x y))&quot; &quot;(vec (zipmap (range 1 10) (range 1 10))) &quot; &quot;(vec (zipmap (range 20 50) (range 100 100))) &quot; &quot;(vec (zipmap (range 20 50) '(100))) &quot; &quot;(vec (zipmap (range 20 50) (lazy-seq 100))) &quot; &quot;(repeat 100)&quot; &quot;(vec (zipmap (range 20 50) (repeat 100))) &quot; &quot;(def snake-body [[1 2] [2 2] [3 2] [1 2]])&quot; &quot;(contains? snake-body [1 2])&quot; &quot;(doc contains?)&quot; &quot;(contains? [1 2 3 4 5] 1)&quot; &quot;(contains? [1 2 3 4 5] 10)&quot; &quot;(contains? [1 2 3 4 5] 2)&quot; &quot;(contains? [1 2 3 4 5] 0)&quot; &quot;(contains? [1 2 3 4 5] -1)&quot; &quot;(contains? [[1]] [1])&quot; &quot;(contains? [[1]] 1)&quot; &quot;(get [1 2 3] 1)&quot; &quot;(get [1 2 3] 3)&quot; &quot;(doc some)&quot; &quot;(some #{[1 2]} [[1 2] [0 1]])&quot; &quot;(some #{[1 2]} (rest [[1 2] [0 1] [1 1] [1 4]]))&quot; &quot;(some #{[1 2]} [[1 2] [0 1] [1 1] [1 4]])&quot; &quot;(some #{[1 2]} (rest [[1 2] [0 1] [1 1] [1 4] [1 2]]))&quot; &quot;[[]]&quot; &quot;(def snake-body [[1 2] [2 2] [3 2] [1 2] :dead false])&quot; &quot;(pop snake-body)&quot; &quot;(def snake-body ([[1 2] [2 2] [3 2] [1 2]] :dead false))&quot; &quot;(def snake-body '([[1 2] [2 2] [3 2] [1 2]] :dead false))&quot; &quot;(first snake-body)&quot; &quot;(load-file \&quot;snake.core.clj\&quot;)&quot; &quot;(load-file \&quot;core.clj\&quot;)&quot; &quot;(load-file \&quot;scr/snake/core.clj\&quot;)&quot; &quot;(load-file \&quot;src/snake/core.clj\&quot;)&quot; &quot;(def snake-body (atom (list (create-snake 40) :dead false)))&quot; &quot;(:dead @snake-)&quot; &quot;(:dead @snake-body)&quot; &quot;(:dead (second @snake-body))&quot; &quot;(swap! snake-body (list (first snake-body) {:dead true}))&quot; &quot;(def ma {:dead true})&quot; &quot;(:dead ma false)&quot; &quot;ma&quot; &quot;(swap! (first @snake-body) list {:dead true?})&quot; &quot;(swap! (first @snake-body) list {:dead true})&quot; &quot;(swap! snake-body) list {:dead true})&quot; &quot;(swap! snake-body list {:dead true})&quot; &quot;(doc into)&quot; &quot;(doc into @snake-body)&quot; &quot;(doc into @snake-body {:alive false})&quot; &quot;(doc into-array)&quot; &quot;(into-array '([1 2] [1 2]))&quot; &quot;\n(def snake-body (atom (list (create-snake 40) {:dead false})))&quot; &quot;@snake-body&quot; &quot;[let sn (first @snake-body) (println sn)]&quot; &quot;(let [sn (first @snake-body) (println sn)])&quot; &quot;(let [sn (first @snake-body)] (println sn))&quot; &quot;(let [sn (first @snake-body)] \n  (swap! sn conj [99 99]))&quot; &quot;(swap! snake-body #(vec (cons [99 99] (pop (first %)))))&quot; &quot;(def snake-body (atom (list (create-snake 40) {:dead false})))&quot; &quot;(defn v+ [v1 v2]\n  (mapv + v1 v2))&quot; &quot;(defn move-snake []\n  (let [new-head (v+ (first @snake-body) [1 1])]\n    (swap! snake-body #(list (vec (cons new-head (pop (first %)))) {:dead false}))) ;pop tail, add new head\n  )&quot; &quot;(move-snake)&quot; &quot;(def a (atom false))&quot; &quot;(swap! a false?)&quot; &quot;a&quot; &quot;(swap! a false)&quot; &quot;(false? false\n        )&quot; &quot;(false? true)&quot; &quot;(swap! a #(true))&quot; &quot;(swap! a #(return true))&quot; &quot;(swap! a #(and true true)) &quot; &quot;(swap! a #(and true) true) &quot; &quot;(swap! a #(and true %) true) &quot; &quot;(swap! a #(and true))&quot; &quot;(defn x [] true)&quot; &quot;(x)&quot; &quot;(defn x [y] true)&quot; &quot;(swap! a x)&quot; &quot;(swap! a #(or true %))&quot; &quot;(- 50 40)&quot; &quot;(defn create-snake [length]\n  (mapv #(vec (list % 50)) (range (- 50 length) 50)))&quot; &quot;(create-snake 40)&quot;], :remote []}}</component>
</project>